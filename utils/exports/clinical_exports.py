import io
import os
import pandas as pd
import streamlit as st
from datetime import datetime
from pathlib import Path
from ..system.session_state import SessionStateKeys
from ..system.debug_output import emit_debug


def _count_mapping(df: pd.DataFrame):
    if "Mapping Found" not in df.columns:
        return len(df), 0, len(df)
    matched = df["Mapping Found"].astype(str).str.lower().eq("found").sum()
    total = len(df)
    return total, matched, total - matched


def _generate_csv_with_metadata(filtered_df: pd.DataFrame, xml_label: str) -> str:
    """Generate CSV content with metadata header rows."""
    export_datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Create metadata lines
    metadata_lines = [
        f"# Original XML File: {xml_label}",
        f"# Export Date/Time: {export_datetime}",
        f"# Generated by: ClinXML‚Ñ¢ EMIS XML Toolkit (https://clinxml.streamlit.app)",
        "#",  # Empty comment line for separation
    ]
    
    # Convert DataFrame to CSV string with explicit line terminator
    csv_buffer = io.StringIO()
    filtered_df.to_csv(csv_buffer, index=False, lineterminator='\n')
    csv_content = csv_buffer.getvalue().rstrip('\n\r')  # Remove any trailing newlines/carriage returns
    
    # Combine metadata and CSV content
    return "\n".join(metadata_lines) + "\n" + csv_content


def _generate_filename(base_label: str, current_mode: str, selected_filter: str) -> str:
    """Generate timestamp-based filename for exports."""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    mode_suffix = "unique" if current_mode == "unique_codes" else "per_source"
    filter_suffix = "" if selected_filter == "all" else f"_{selected_filter}"
    clean_label = base_label.replace(' ', '_').lower()
    return f"{clean_label}_{mode_suffix}{filter_suffix}_{timestamp}.csv"


EXPORT_CACHE_DIR = Path("utils/exports/export_cache")


def _cleanup_export_files():
    """Clean up any existing export files on reprocess/file change."""
    if EXPORT_CACHE_DIR.exists():
        files_deleted = 0
        for file_path in EXPORT_CACHE_DIR.glob("*.csv"):
            try:
                file_path.unlink()
                files_deleted += 1
                if st.session_state.get(SessionStateKeys.DEBUG_MODE, False):
                    emit_debug("clinical_exports", f"Export garbage collected: {file_path.name}")
            except Exception as e:
                if st.session_state.get(SessionStateKeys.DEBUG_MODE, False):
                    emit_debug("clinical_exports", f"Export garbage collection failed: {file_path.name} ({e})")
        
        if files_deleted > 0 and st.session_state.get(SessionStateKeys.DEBUG_MODE, False):
            emit_debug("clinical_exports", f"Export garbage collection completed: {files_deleted} file(s)")


def _purge_on_session_change():
    """Purge exports when session changes (file reprocess/change)."""
    if "last_export_cleanup" not in st.session_state:
        st.session_state.last_export_cleanup = None

    # Check for session change indicators
    current_file = st.session_state.get(SessionStateKeys.XML_FILENAME, "")
    last_file = st.session_state.get("last_file_for_export", "")
    
    if current_file != last_file:
        _cleanup_export_files()
        st.session_state.last_file_for_export = current_file
        # Reset all export states
        for key in list(st.session_state.keys()):
            if key.startswith("export_") and key.endswith("_ready"):
                del st.session_state[key]


def render_export_controls(
    export_df: pd.DataFrame,
    base_label: str,
    current_mode: str,
    key_prefix: str,
):
    """
    Render lazy export controls with aggressive garbage collection.
    
    - export_df: DataFrame already filtered for the tab and deduplication mode.
    - base_label: Label used in the download button (e.g., "Standalone Medications").
    - current_mode: "unique_codes" or "unique_per_entity" (for button text).
    - key_prefix: unique key seed per tab to keep state isolated.
    """
    if export_df is None or export_df.empty:
        return

    # Purge exports on session change
    _purge_on_session_change()

    total, matched, unmatched = _count_mapping(export_df)

    # Determine available filters
    options = [("all", "All Codes")]
    if unmatched > 0:
        options.append(("matched", "Only Matched"))
        options.append(("unmatched", "Only Unmatched"))

    # Balanced layout to match the current UI
    col1, col2 = st.columns([1, 2])
    
    with col1:
        selected = st.radio(
            "Export Filter:",
            options=[o[0] for o in options],
            format_func=lambda v: dict(options)[v],
            key=f"{key_prefix}_export_filter",
            horizontal=True,
        )
        st.caption(f"üìä Total: {total} | ‚úÖ Matched: {matched} | ‚ùå Unmatched: {unmatched}")

    # Filter by selection
    filtered = export_df
    if selected == "matched":
        filtered = export_df[export_df["Mapping Found"].astype(str).str.lower().eq("found")]
    elif selected == "unmatched":
        filtered = export_df[~export_df["Mapping Found"].astype(str).str.lower().eq("found")]

    filtered_count = len(filtered)

    with col2:
        mode_label = "Unique" if current_mode == "unique_codes" else "Per Source"
        filter_label = {"all": "All", "matched": "Matched", "unmatched": "Unmatched"}[selected]

        # Generate filename for this export
        filename = _generate_filename(base_label, current_mode, selected)
        export_key = f"export_{key_prefix}_{selected}_{current_mode}"
        file_ready_key = f"{export_key}_ready"
        file_path_key = f"{export_key}_path"

        # Check if file is ready
        is_ready = st.session_state.get(file_ready_key, False)
        stored_path = st.session_state.get(file_path_key, "")

        if is_ready and stored_path and Path(stored_path).exists():
            # File is ready - show download button
            btn_label = f"üì• Download {filter_label} {base_label} ({mode_label})"
            tooltip = f"File Ready To Download: {filename}"
            
            # Create download button with file content
            with open(stored_path, 'rb') as f:
                file_data = f.read()
            
            downloaded = st.download_button(
                btn_label,
                data=file_data,
                file_name=filename,
                mime="text/csv",
                key=f"{export_key}_download",
                help=tooltip,
            )
            
            # If downloaded, clean up immediately
            if downloaded:
                try:
                    Path(stored_path).unlink()
                    if st.session_state.get(SessionStateKeys.DEBUG_MODE, False):
                        emit_debug("clinical_exports", f"Export garbage collected: {filename}")
                except Exception as e:
                    if st.session_state.get(SessionStateKeys.DEBUG_MODE, False):
                        emit_debug("clinical_exports", f"Export garbage collection failed: {filename} ({e})")
                # Reset state to generate mode
                if file_ready_key in st.session_state:
                    del st.session_state[file_ready_key]
                if file_path_key in st.session_state:
                    del st.session_state[file_path_key]
                st.rerun()
        
        else:
            # File not ready - show generate button
            btn_label = f"üîÑ Export {filter_label} {base_label} ({mode_label})"
            tooltip = f"Generate CSV: {filename}"
            
            if st.button(
                btn_label,
                key=f"{export_key}_generate",
                help=tooltip,
            ):
                # Generate file
                EXPORT_CACHE_DIR.mkdir(parents=True, exist_ok=True)
                file_path = EXPORT_CACHE_DIR / filename

                # Get original filename from session state
                original_filename = st.session_state.get(SessionStateKeys.XML_FILENAME, "Unknown")
                
                # Remove debug-only columns before export
                filtered_for_export = filtered.copy()
                if 'debug_fields' in filtered_for_export.columns:
                    filtered_for_export = filtered_for_export.drop(columns=['debug_fields'])
                
                # Generate CSV with metadata
                csv_content = _generate_csv_with_metadata(filtered_for_export, original_filename)
                
                # Write CSV
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(csv_content)
                
                if st.session_state.get(SessionStateKeys.DEBUG_MODE, False):
                    file_size_kb = len(csv_content.encode('utf-8')) / 1024
                    emit_debug(
                        "clinical_exports",
                        f"Export created: {filename} ({file_size_kb:.1f}KB, {len(filtered_for_export)} rows)"
                    )
                
                # Update state
                st.session_state[file_ready_key] = True
                st.session_state[file_path_key] = str(file_path)
                st.rerun()
        
        # CSV info text goes under the download button in the right column
        st.caption(f"Will generate CSV with {filtered_count} rows √ó {len(export_df.columns)} columns")
