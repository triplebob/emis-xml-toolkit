"""
Analytics export module for exporting analysis summaries as JSON or CSV.
"""

import json
import io
import streamlit as st
from datetime import datetime
from pathlib import Path
from ..system.session_state import SessionStateKeys


def _generate_analytics_json(
    xml_stats: dict,
    xml_structure: dict,
    search_count: int,
    report_count: int,
    folder_count: int,
    report_types: dict,
    translation_stats: dict,
    quality_indicators: dict,
    code_system_distribution: dict,
    emisinternal_count: int,
) -> str:
    """Generate JSON export of analytics summary."""
    export_data = {
        "export_metadata": {
            "export_datetime": datetime.now().isoformat(),
            "source": "ClinXML Analytics",
            "version": "2.0",
            "url": "https://clinxml.streamlit.app/"
        },
        "file_information": xml_stats,
        "xml_structure": {
            **xml_structure,
            "clinical_searches": search_count,
            "reports_found": report_count,
            "folders_found": folder_count,
            "report_types": report_types,
        },
        "translation_and_mapping": translation_stats,
        "quality_indicators": quality_indicators,
        "code_system_distribution": code_system_distribution,
        "emisinternal_codes_excluded": emisinternal_count,
    }

    return json.dumps(export_data, indent=2, default=str)


def _generate_analytics_csv(
    xml_stats: dict,
    xml_structure: dict,
    search_count: int,
    report_count: int,
    folder_count: int,
    report_types: dict,
    translation_stats: dict,
    quality_indicators: dict,
    code_system_distribution: dict,
    emisinternal_count: int,
) -> str:
    """Generate CSV export of analytics summary."""
    export_datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    xml_filename = xml_stats.get("filename", "Unknown")

    lines = [
        "# ClinXML Analytics Summary Export",
        f"# Original XML File: {xml_filename}",
        f"# Export Date/Time: {export_datetime}",
        f"# Generated by: ClinXMLâ„¢ EMIS XML Toolkit (https://clinxml.streamlit.app)",
        "#",
        "",
        "Section,Metric,Value",
        "",
        "# File Information",
        f"File Information,Filename,{xml_stats.get('filename', 'Unknown')}",
        f"File Information,File Size (bytes),{xml_stats.get('file_size_bytes', 0)}",
        f"File Information,Processing Time (seconds),{xml_stats.get('processing_time_seconds', 'N/A')}",
        f"File Information,Processed Timestamp,{xml_stats.get('processing_timestamp', 'N/A')}",
        "",
        "# XML Structure Analysis",
        f"XML Structure,Total ValueSets,{xml_structure.get('total_valuesets', 0)}",
        f"XML Structure,Unique EMIS GUIDs,{xml_structure.get('unique_emis_guids', 0)}",
        f"XML Structure,Total GUID References,{xml_structure.get('total_guid_occurrences', 0)}",
        f"XML Structure,Duplication Rate (%),{xml_structure.get('duplicate_guid_ratio', 0)}",
        f"XML Structure,Folders Found,{folder_count}",
        f"XML Structure,Clinical Searches,{search_count}",
        f"XML Structure,Reports Found,{report_count}",
        f"XML Structure,List Reports,{report_types.get('List', 0)}",
        f"XML Structure,Audit Reports,{report_types.get('Audit', 0)}",
        f"XML Structure,Aggregate Reports,{report_types.get('Aggregate', 0)}",
        "",
        "# Translation & Mapping Success",
        f"Translation & Mapping,Clinical Codes Found,{translation_stats.get('clinical_found', 0)}",
        f"Translation & Mapping,Clinical Codes Total,{translation_stats.get('clinical_total', 0)}",
        f"Translation & Mapping,Search Clinical Found,{translation_stats.get('search_found', 0)}",
        f"Translation & Mapping,Search Clinical Total,{translation_stats.get('search_total', 0)}",
        f"Translation & Mapping,Report Clinical Found,{translation_stats.get('report_found', 0)}",
        f"Translation & Mapping,Report Clinical Total,{translation_stats.get('report_total', 0)}",
        f"Translation & Mapping,Medications Found,{translation_stats.get('meds_found', 0)}",
        f"Translation & Mapping,Medications Total,{translation_stats.get('meds_total', 0)}",
        f"Translation & Mapping,Search Medications Found,{translation_stats.get('meds_search_found', 0)}",
        f"Translation & Mapping,Search Medications Total,{translation_stats.get('meds_search_total', 0)}",
        f"Translation & Mapping,Report Medications Found,{translation_stats.get('meds_report_found', 0)}",
        f"Translation & Mapping,Report Medications Total,{translation_stats.get('meds_report_total', 0)}",
        f"Translation & Mapping,Refsets Found,{translation_stats.get('refset_found', 0)}",
        f"Translation & Mapping,Refsets Total,{translation_stats.get('refset_total', 0)}",
        f"Translation & Mapping,Pseudo Members Found,{translation_stats.get('pseudo_found', 0)}",
        f"Translation & Mapping,Pseudo Members Total,{translation_stats.get('pseudo_total', 0)}",
        f"Translation & Mapping,Search Pseudo Members Found,{translation_stats.get('pseudo_search_found', 0)}",
        f"Translation & Mapping,Search Pseudo Members Total,{translation_stats.get('pseudo_search_total', 0)}",
        f"Translation & Mapping,Report Pseudo Members Found,{translation_stats.get('pseudo_report_found', 0)}",
        f"Translation & Mapping,Report Pseudo Members Total,{translation_stats.get('pseudo_report_total', 0)}",
        "",
        "# Quality Indicators",
        f"Quality,Codes With Include Children,{quality_indicators.get('has_children', 0)}",
        f"Quality,Codes Flagged With Qualifiers,{quality_indicators.get('qualifier_true', 0)}",
        f"Quality,Display Names Present,{quality_indicators.get('display_names', 0)}",
        f"Quality,Display Names Percentage,{quality_indicators.get('display_pct', 0):.1f}",
        f"Quality,Table Context Available,{quality_indicators.get('table_ctx', 0)}",
        f"Quality,Table Context Percentage,{quality_indicators.get('table_ctx_pct', 0):.1f}",
        f"Quality,Column Context Available,{quality_indicators.get('column_ctx', 0)}",
        f"Quality,Column Context Percentage,{quality_indicators.get('column_ctx_pct', 0):.1f}",
        f"Quality,EMISINTERNAL Codes (Excluded),{emisinternal_count}",
        "",
        "# Code System Distribution",
    ]

    for code_system, count in code_system_distribution.items():
        lines.append(f"Code System Distribution,{code_system},{count}")

    return "\n".join(lines)


def render_analytics_export_controls(analytics_data: dict):
    """
    Render lazy export controls for analytics tab.

    Args:
        analytics_data: Dictionary containing all analytics data to export
    """
    if not analytics_data:
        st.markdown("No analytics data available for export.")
        return

    # Extract and clean XML filename
    xml_filename = analytics_data.get("xml_stats", {}).get("filename", "analytics_summary")
    # Remove .xml extension and clean for filesystem
    if xml_filename.lower().endswith('.xml'):
        xml_filename = xml_filename[:-4]
    # Replace problematic characters
    clean_filename = xml_filename.replace(' ', '_').replace('/', '-').replace('\\', '-')

    st.write("### ðŸ“¤ Export Analytics")
    st.markdown("")
    col1, col2 = st.columns([0.5, 1.5])

    # CSV Export
    with col1:
        csv_key = "analytics_export_csv"
        csv_ready_key = f"{csv_key}_ready"
        csv_data_key = f"{csv_key}_data"

        is_csv_ready = st.session_state.get(csv_ready_key, False)

        if is_csv_ready:
            # Download ready
            csv_data = st.session_state.get(csv_data_key, "")
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{clean_filename}_analytics_summary_{timestamp}.csv"

            downloaded = st.download_button(
                "ðŸ“¥ Download Analytics Summary (CSV)",
                data=csv_data,
                file_name=filename,
                mime="text/csv",
                help=f"Download analytics summary as CSV: {filename}",
                key=f"{csv_key}_download"
            )

            if downloaded:
                # Clean up state after download
                if csv_ready_key in st.session_state:
                    del st.session_state[csv_ready_key]
                if csv_data_key in st.session_state:
                    del st.session_state[csv_data_key]
                st.rerun()
        else:
            # Generate button
            if st.button(
                "ðŸ”„ Export Analytics Summary (CSV)",
                help="Generate CSV export of analytics summary",
                key=f"{csv_key}_generate"
            ):
                with st.spinner("Generating CSV export..."):
                    csv_content = _generate_analytics_csv(
                        xml_stats=analytics_data.get("xml_stats", {}),
                        xml_structure=analytics_data.get("xml_structure", {}),
                        search_count=analytics_data.get("search_count", 0),
                        report_count=analytics_data.get("report_count", 0),
                        folder_count=analytics_data.get("folder_count", 0),
                        report_types=analytics_data.get("report_types", {}),
                        translation_stats=analytics_data.get("translation_stats", {}),
                        quality_indicators=analytics_data.get("quality_indicators", {}),
                        code_system_distribution=analytics_data.get("code_system_distribution", {}),
                        emisinternal_count=analytics_data.get("emisinternal_count", 0),
                    )

                    st.session_state[csv_ready_key] = True
                    st.session_state[csv_data_key] = csv_content
                    st.rerun()

    # JSON Export
    with col2:
        json_key = "analytics_export_json"
        json_ready_key = f"{json_key}_ready"
        json_data_key = f"{json_key}_data"

        is_json_ready = st.session_state.get(json_ready_key, False)

        if is_json_ready:
            # Download ready
            json_data = st.session_state.get(json_data_key, "")
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{clean_filename}_analytics_summary_{timestamp}.json"

            downloaded = st.download_button(
                "ðŸ“¥ Download Analytics Summary (JSON)",
                data=json_data,
                file_name=filename,
                mime="application/json",
                help=f"Download analytics summary as JSON: {filename}",
                key=f"{json_key}_download"
            )

            if downloaded:
                # Clean up state after download
                if json_ready_key in st.session_state:
                    del st.session_state[json_ready_key]
                if json_data_key in st.session_state:
                    del st.session_state[json_data_key]
                st.rerun()
        else:
            # Generate button
            if st.button(
                "ðŸ”„ Export Analytics Summary (JSON)",
                help="Generate JSON export of analytics summary",
                key=f"{json_key}_generate"
            ):
                with st.spinner("Generating JSON export..."):
                    json_content = _generate_analytics_json(
                        xml_stats=analytics_data.get("xml_stats", {}),
                        xml_structure=analytics_data.get("xml_structure", {}),
                        search_count=analytics_data.get("search_count", 0),
                        report_count=analytics_data.get("report_count", 0),
                        folder_count=analytics_data.get("folder_count", 0),
                        report_types=analytics_data.get("report_types", {}),
                        translation_stats=analytics_data.get("translation_stats", {}),
                        quality_indicators=analytics_data.get("quality_indicators", {}),
                        code_system_distribution=analytics_data.get("code_system_distribution", {}),
                        emisinternal_count=analytics_data.get("emisinternal_count", 0),
                    )

                    st.session_state[json_ready_key] = True
                    st.session_state[json_data_key] = json_content
                    st.rerun()
