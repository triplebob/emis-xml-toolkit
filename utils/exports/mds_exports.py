"""Lazy CSV export helpers for the Analytics -> MDS tab."""

from __future__ import annotations

import csv
import gc
from datetime import datetime
from io import StringIO
from pathlib import Path
from typing import Any, Dict, List

import streamlit as st

from ..system.debug_output import emit_debug


def _ordered_columns(rows: List[Dict[str, Any]]) -> List[str]:
    """Return stable output columns based on row content."""
    base_columns = ["emis_guid", "snomed_code", "description", "code_type", "mapping_status"]
    source_columns = ["source_type", "source_name", "source_guid"]
    optional_columns = ["emis_xml"]

    keys = set()
    for row in rows:
        keys.update(row.keys())

    ordered: List[str] = [col for col in base_columns if col in keys]
    ordered.extend(col for col in source_columns if col in keys)
    ordered.extend(col for col in optional_columns if col in keys)

    extras = sorted(key for key in keys if key not in ordered)
    ordered.extend(extras)
    return ordered


def build_mds_export_filename(xml_filename: str, view_mode: str = "unique_codes") -> str:
    """Build a safe export filename for the current XML + mode."""
    base_name = Path(str(xml_filename) or "clinxml").stem
    safe_base = base_name.replace(" ", "_").replace("/", "-").replace("\\", "-")

    mode_label = "per_source" if view_mode == "per_source" else "unique_codes"
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    return f"{safe_base}_MDS_{mode_label}_{timestamp}.csv"


def build_mds_csv(
    rows: List[Dict[str, Any]],
    *,
    xml_filename: str = "",
    include_footer: bool = False,
) -> str:
    """Serialize rows to CSV using stable column ordering."""
    if not rows:
        return ""

    columns = _ordered_columns(rows)
    buffer = StringIO()
    writer = csv.DictWriter(buffer, fieldnames=columns, extrasaction="ignore", lineterminator="\n")
    writer.writeheader()
    for row in rows:
        writer.writerow({column: row.get(column, "") for column in columns})

    csv_content = buffer.getvalue().rstrip("\n\r")
    if not include_footer:
        return csv_content

    footer_buffer = StringIO()
    footer_writer = csv.writer(footer_buffer, lineterminator="\n")
    # Two blank rows before footer metadata.
    footer_writer.writerow([])
    footer_writer.writerow([])
    footer_writer.writerow(["XML Filename", xml_filename or "Unknown"])
    footer_writer.writerow(["Generated by", "ClinXMLâ„¢ EMIS XML Toolkit (https://clinxml.streamlit.app)"])
    footer_writer.writerow(["Date Exported", datetime.now().strftime("%Y-%m-%d %H:%M:%S")])

    return csv_content + "\n" + footer_buffer.getvalue().rstrip("\n\r")


def render_mds_export_controls(
    *,
    rows: List[Dict[str, Any]],
    xml_filename: str,
    view_mode: str,
    state_prefix: str = "mds_export",
    context_token: str = "",
) -> None:
    """Render lazy on-demand CSV export controls with immediate post-download cleanup."""
    if not rows:
        return

    # Context must be stable across reruns for the same dataset/view;
    # filename includes a timestamp and is generated only when needed.
    base_name = Path(str(xml_filename) or "clinxml").stem
    mode_label = "per_source" if view_mode == "per_source" else "unique_codes"
    context_id = f"{base_name}|{mode_label}|{len(rows)}|{context_token}"

    state_key = f"{state_prefix}_state"
    state = st.session_state.get(state_key, {})
    if state.get("context") != context_id:
        state = {"context": context_id, "ready": False, "filename": "", "content": ""}
        st.session_state[state_key] = state

    if state.get("ready"):
        ready_filename = state.get("filename") or build_mds_export_filename(xml_filename, view_mode=view_mode)
        download_help = f"Start Download: {ready_filename}"
        downloaded = st.download_button(
            "ðŸ“¥ Download MDS (CSV)",
            data=state.get("content", ""),
            file_name=ready_filename,
            mime="text/csv",
            key=f"{state_prefix}_download",
            disabled=not state.get("content"),
            help=download_help,
            width="stretch",
        )
        if downloaded:
            emit_debug(
                "mds_exports",
                f"Export garbage collected: {state.get('filename') or 'mds_export.csv'}",
            )
            st.session_state.pop(state_key, None)
            gc.collect()
            emit_debug("mds_exports", "Export garbage collection completed: 1 export payload")
            st.rerun()
    else:
        next_filename = build_mds_export_filename(xml_filename, view_mode=view_mode)
        generate_help = f"Generate CSV: {next_filename}"
        if st.button(
            "ðŸ”„ Generate MDS (CSV)",
            key=f"{state_prefix}_generate",
            help=generate_help,
            width="stretch",
        ):
            generated_filename = build_mds_export_filename(xml_filename, view_mode=view_mode)
            csv_content = build_mds_csv(
                rows,
                xml_filename=xml_filename,
                include_footer=True,
            )
            st.session_state[state_key] = {
                "context": context_id,
                "ready": True,
                "filename": generated_filename,
                "content": csv_content,
            }
            file_size_kb = len(csv_content.encode("utf-8")) / 1024 if csv_content else 0.0
            emit_debug(
                "mds_exports",
                f"Export created: {generated_filename} ({file_size_kb:.1f}KB, {len(rows)} rows)",
            )
            st.rerun()
